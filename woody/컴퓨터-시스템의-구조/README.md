## 운영체제 개요

### OS(Operating System) 란?

- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층 
- 사용자 소프트웨어에게 편리한 하드웨어 인터페이스를 제공한다
  - 컴퓨터 시스템 내부를 알지 못하더라도 편하게 사용할 수 있다

- 컴퓨터 자원을 효율적으로 관리
  - 컴퓨터 자원 ( CPU, 메모리, I/O 장치 등 ) 관리
  - 형평성 : 특정 사용자 프로그램이 자원을 독점하지 않도록
  - 효율성 : 한정된 자원을 통해 최대한 성능을 내도록

**동시성(Concurrency)**

- 동시 사용자/프로그램이 각각 독자적인 컴퓨터에서 수행되는 것 같은 환상을 제공한다
- 서로 다른 여러개의 프로그램을 빠르게 전환(context switching)하며 조금씩 수행한다

</br>

### CPU 스케줄링

**FCFS : First Come First Served**

- 효율적이지는 않음
- 프로세스들이 기다리는 시간이 길어짐

**SJF (Shortest Job First)**

- CPU 사용시간이 가장 짧은 프로세스를 제일 먼저 스케줄링한다
- 모든 프로세스의 평균 대기시간을 가장 최소로 유지할 수 있다
- 기아현상 발생 가능 - CPU 사용시간이 가장 긴 프로세스는 영원히 CPU 할당을 못받는 경우가..

**RR (Round Robin)**

- 각 프로세스는 동일 크기의 CPU 할당 시간을 가짐
- 할당 시간이 끝나면 CPU 큐 맨 뒤에 다시 줄선다
- 프로그램 실행 도중 CPU 점유를 뺏어와야 하기 때문에 하드웨어 도움을 받아 인터럽트로 점유를 가져온다



>  운영체제 개요 - 메모리 관리부터 다시 수강 및 정리 해야 함

</br>

## 컴퓨터 시스템 구조

### 전체 구성도

![컴퓨터-전체-구조](./imgs/컴퓨터-전체-구조.png)



</br>

### Mode bit

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치의 필요성

Mode bit = 하드웨어적으로 두 가지 모드의 operation 지원

1 사용자 모드 : 사용자 프로그램 수행

2 커널 모드 : OS 코드 수행

- 보안을 해칠 수 있는 중요 명령어는 커널 모드에서만 수행 가능한 '특권 명령'으로 규정
- 인터럽트나 예외 발생 시 하드웨어가 mode bit을 0으로 바꿈
- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅

</br>

### PC 레지스터

다음 번에 실행할 프로그램의 주소를 가리킴

</br>

### Timer

일정 시간 간격을 두고 **운영체제에게 제어권이 넘어가도록 인터럽트를 발생**시킴

- 특정 프로그램이 CPU를 독점하지 않도록 보호
- 타이머는 매 클럭 틱 때마다 1씩 감소
- CPU 스케줄링의 도구

</br>

### 인터럽트 (Interrupt)

- 인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다

**Interrupt(하드웨어 인터럽트)**

하드웨어가 발생시킨 인터럽트

- I/O 장치, 키보드, 프린트, 모니터 등이 작업을 끝내고 CPU에게 작업 다했다고 알릴 때 사용하는 인터럽트
- 하드웨어에서 전달된 정보를 처리하기 위해 인터럽트를 걸고, CPU 점유를 OS에게 넘긴다(커널 모드 전환)

**Trap(소프트웨어 인터럽트)**

사용자 프로그램이 OS 기능을 사용하기 위해 발생시킨 인터럽트

- Exception : 프로그램이 오류를 범한 경우
- System call : 프로그램이 커널 함수를 호출하는 경우

</br>

> **Device Driver**
>
> - 컴퓨터 내부에서 디스크 작업 요청 위해 CPU가 수행하는 코드(소프트웨어)
>
> **Device Controller(하드웨어)**
>
> - 각 하드웨어 장치를 통제하는 하드웨어



### 하드웨어 인터럽트 작업 순서

1. 메모리에서 기계어를 실행하기 전 혹시 인터럽트가 발생하지 않았는지 체크
2. CPU가 디스크 컨트롤러에게 업무를 준다
3. CPU는 그동안 다른 일 수행
4. 디스크에서 일을 다 수행하면 디스크 컨트롤러가 CPU에게 인터럽트를 건다
5. CPU 점유는 자동으로 OS에게 넘어가게 됨(mode bit 0)
6. 인터럽트와 관련된 일을 먼저 수행하게 된다



### 소프트웨어 인터럽트 : System Call(시스템 콜) 순서

사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

- 소프트웨어 인터럽트의 한 종류

1. 사용자 프로그램에서 시스템콜 고유번호(0x08)를 레지스터에 저장하고 시스템 콜을 호출
2. 사용자 인터럽트(Trap)가 수행되고 커널모드로 전환
3. OS에서 시스템콜을 호출 및 작업 수행

<img src="./imgs/시스템콜.png" alt="시스템콜" style="zoom:50%;" />

</br>



### 동기 / 비동기 입출력

**동기식 입출력(synchronous I/O)**

I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감

- 구현 방법 1
  - I/O가 끝날 때 까지 CPU를 낭비시킴
  - 매 시점 하나의 I/O만 일어날 수 있음
- 구현 방법 2
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
  - I/O처리를 기다리는 줄에 그 프로그램을 줄 세움
  - 다른 프로그램에게 CPU를 줌

**비동기식 입출력(asynchronous)**

I/O 가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

> 두 경우 모두 I/O 작업의 완료는 인터럽트로 알려준다

</br>

### DMA (Direct Memory Access)

메모리에 직접 접근할 수 있는 중간 장치

일정 수준의 하드웨어 처리가 완료되면 여러 디스크 작업 요청을 CPU 인터럽트를 통해 한 번에 요청한다



#### 왜 필요할까?

작은 크기의 하드웨어 작업이 빈번하게 이루어지고 그때마다 인터럽트를 걸게되면

→ 인터럽트 오버헤드가 너무 많아져 비효율적



### DMA가 없다면

하드웨어가 버퍼에 작업이 완료된 데이터를 저장해놓고 이를 메모리로 옮겨야하는데, 디스크 컨트롤러는 메모리에 이 데이터를 올려놓는 일을 할 수 없다. 그래서 CPU 인터럽트를 걸고 CPU 메모리에 올려놓는 작업을 한다

이렇게 되면, CPU가 메모리에 데이터를 올리고 해당 데이터를 처리하는 작업까지 실행해야 한다.

### DMA가 있다면

DMA controller에서 블럭 단위로 하드웨어에서 완료된 작업들을 저장하고 있다가 일정 크기가 차면, CPU 인터럽트 없이 스스로 메모리에 데이터를 올리는 작업을 진행한다. 그리고 나서 CPU에게 해당 데이터와 관련된 작업을 처리해달라고 그제서야 인터럽트를 건다.

한 마디로, 디스크 작업을 모아 한 번에 메모리에 올리고, 마지막에 인터럽트를 걸기 때문에 CPU 부담이 적다

</br>

### 저장장치 계층 구조

더 아래 계층으로 내려가기 전에, 내가 이미 가지고 있는 내용이면 바로 읽어서 가져올 수 있다

**Primary**

CPU에서 바로 접근이 가능한 영역

- 휘발성 데이터

**Secondary**

I/O 요청을 통해 접근할 수 있는 영역

- 비휘발성 데이터